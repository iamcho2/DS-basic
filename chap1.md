# 자료구조와 알고리즘의 이해

모르는 것, 알게된 것, 까먹을 것 같은 것들 모아놓기


#### 공부방법

* 손으로 자료구조의 모델을 수십 번 그려보고 이를 코드로 옮기면서 의미 찾기
* 자료 구조의 모델 자체에 대한 이해가 중요!



#### 필요한 C 문법

- [ ] 구조체 정의, 구조체 대상의 `typedef` 선언
- [ ] malloc 함수, free 함수 사용 / 이는 메모리의 동적 할당과 관련 있음을 이해
- [ ] 포인터 변수의 선언과 포인터 연산에 부담 X
- [ ] 헤더파일이 필요한 이유를 이해
- [ ] 헤더파일을 정의할 줄 알고 헤더파일에 들어가야 할 것들이 무엇인지 알고 있음
- [ ] 헤더파일의 정의에 사용되는 매크로 #ifndef ~ #endif 의 의미를 알고 있음
- [ ] 하나의 프로그램을 둘 이상의 소스파일과 헤더파일에 나누어 담을 줄 앎
- [x] 재귀함수의 동작방식을 알고 있음 / 재귀함수와 관련된 아주 간단한 예제는 분석할 수 있음

<br>

## 자료구조

### 분류

* 선형구조
  * 데이터를 나란히, 일렬로 저장하는 형태
  * 리스트, 스택, 큐
* 비선형구조
  * 트리, 그래프
* 파일구조
  * 순차파일, 색인파일, 직접파일
* 단순구조
  * 정수, 실수, 문자, 문자열

> 이 책으로는 선형구조 / 비선형구조를 공부

<br>

## 알고리즘의 성능분석 방법

### 시간복잡도와 공간복잡도

* 시간복잡도 : **속도**에 해당하는 알고리즘의 수행시간 분석결과
* 공간복잡도 : **메모리 사용량**에 대한 분석결과

> 일반적으로 알고리즘을 평가할 때는 메모리의 사용량보다 실행속도에 초점을 둠

<br>

### 시간복잡도 분석의 핵심요소

* 탐색 알고리즘 - `==` 연산 ( 동등비교 연산 )을 적게 수행하는 탐색 알고리즘이 좋은 탐색 알고리즘  [<sup>1</sup>](#1)
  * `==` 연산의 횟수를 대상으로 시간 복잡도를 분석.
* 알고리즘의 시간 복잡도를 계산하기
  * 핵심이 되는 연산이 무엇인지 잘 판단하기
  * 그 연산을 중심으로 시간 복잡도를 계산하기

<br>

### 이진탐색 알고리즘

* 데이터가 정렬되어 있을 때만 사용 가능

* 인덱스값을 반으로 나눌 때, 나머지를 버림 ( `/` 연산 )
* first == last 인 상황에서도 알고리즘은 계속되어야 함 (탐색의 대상이 하나 남음)
  * 반복 조건 first <= last
  * first > last 가 될 때 탐색 종료, 이는 탐색에 실패했음을 뜻함
* for문 돌릴 때, first & last 초기화 시 **mid+1, mid-1** 주의!
  * 이유 : 탐색의 대상이 배열에 없을 때 무한루프 (first <= mid <= last)

<br>

### 빅-오

* 데이터 수의 증가에 따른 연산횟수의 **증가 형태 (패턴)** 을 나타내는 표기법

* 읽는법 :  big o of ~
* T(n)이 다항식으로 표현된 경우 : 최고차항의 차수 (앞에 계수가 뭐든지 다 뗌)



* 대표적인 빅-오
  * **O(1)** - 상수형 빅-오
    * 데이터 수에 상관없이 연산횟수가 고정인 알고리즘을 대표한다는 의미
  * **O(log n)** - 로그형 빅-오
    * 데이터 수의 증가율에 비해 연산횟수의 증가율이 훨씬 낮은 알고리즘을 의미
  * **O(n)** - 선형 빅-오
    * 데이터의 수와 연산횟수가 비례하는 알고리즘을 의미
  * **O(nlogn)** - 선형로그형 빅-오
    * 데이터의 수가 두 배로 늘 때, 연산횟수는 두 배를 조금 넘게 증가하는 알고리즘을 의미
  * **O(n<sup>2</sup>)**
    * 데이터 수의 두 배에 해당하는 연산횟수를 요구하는 알고리즘을 의미
  * **O(n<sup>3</sup>)**
    * 데이터 수의 세 배에 해당하는 연산횟수를 요구하는 알고리즘을 의미
  * **O(2<sup>n</sup>)** - 지수형 빅-오
    * 사용하기에 매우매우 무리가 있음
* 대소 정리
  * O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>)

<br>

## 궁금한 것들

* [ ] `1`<a class="anchor" id="1"></a>

 *탐색 알고리즘에서의 핵심 : 동등비교 == 를 적게 수행하는 탐색 알고리즘이 좋은 탐색 알고리즘이다.*

 *다른 연산들(ex : <, ++ ...) 은 == 연산에 의존적이다.* ***왜?***

- -

- [ ] ***연산횟수를 계산할 때, ++랑 < 같은 것도 포함되는지?***

* -